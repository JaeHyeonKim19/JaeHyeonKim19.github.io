{"componentChunkName":"component---src-templates-post-template-jsx","path":"/codingtest/programmers-hotter/2019-12-27%2008:26:28%20-0400","result":{"pageContext":{"html":"<blockquote>\n<p>자체풀이</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.*;\nclass Solution {\n    public int solution(int[] scoville, int K) {\n        int answer = 0;\n        ArrayList&#x3C;Integer> scovilleList = new ArrayList&#x3C;Integer>();\n\n        for(int scovilleItem:scoville){\n            scovilleList.add(scovilleItem);\n        }\n        int criteria = scovilleList.get(0);\n        while(criteria&#x3C;K &#x26;&#x26; scovilleList.size()>1){\n            answer++;\n            int easiestOne = scovilleList.remove(0);\n            int secondaryOne = scovilleList.remove(0);\n            int newOne = easiestOne + secondaryOne*2;\n            scovilleList.add(0, newOne);\n            for(int i = 1;i&#x3C;scovilleList.size();i++){\n                if(scovilleList.get(i-1)>scovilleList.get(i)){\n                    int temp = scovilleList.remove(i);\n                    scovilleList.add(i-1, temp);\n                }else{\n                    break;\n                }\n            }\n            criteria = scovilleList.get(0);\n        }\n\n        if(scovilleList.size()==1 &#x26;&#x26; criteria&#x3C;K){\n            return -1;\n        }\n        return answer;\n    }\n}\n</code></pre>\n<ul>\n<li>\n<p>결과</p>\n<ul>\n<li>정확성: 2, 3, 7, 10, 15 실패</li>\n<li>효율성: 전체 실패</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>자체풀이2(다 합쳐도 K를 넘을 수 없는 경우 추가)</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.*;\nclass Solution {\n    public int solution(int[] scoville, int K) {\n        int answer = 0;\n        ArrayList&#x3C;Integer> scovilleList = new ArrayList&#x3C;Integer>();\n\n        for(int scovilleItem:scoville){\n            scovilleList.add(scovilleItem);\n        }\n        scovilleList.sort(null);\n        int criteria = scovilleList.get(0);\n        while(criteria&#x3C;K &#x26;&#x26; scovilleList.size()>1){\n            answer++;\n            int easiestOne = scovilleList.remove(0);\n            int secondaryOne = scovilleList.remove(0);\n            int newOne = easiestOne + secondaryOne*2;\n            scovilleList.add(0, newOne);\n            for(int i = 1;i&#x3C;scovilleList.size();i++){\n                if(scovilleList.get(i-1)>scovilleList.get(i)){\n                    int temp = scovilleList.remove(i);\n                    scovilleList.add(i-1, temp);\n                }else{\n                    break;\n                }\n            }\n            criteria = scovilleList.get(0);\n        }\n\n        if(scovilleList.size()==1 &#x26;&#x26; criteria&#x3C;K){\n            return -1;\n        }\n        return answer;\n    }\n}\n</code></pre>\n<ul>\n<li>\n<p>결과</p>\n<ul>\n<li>정확성: 전체 통과</li>\n<li>효율성: 전체 실패</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>min Heap의 일부를 직접 구현</p>\n</blockquote>\n<pre><code class=\"language-java\">class Solution {\n    int [] orderedScoville;\n    int currentIndex = -1;\n\n    void offer(int newVal){\n        currentIndex++;\n        orderedScoville[currentIndex] = newVal;\n        int temp = currentIndex;\n        while(temp!=0){\n            if(orderedScoville[temp]&#x3C;orderedScoville[(temp+1)/2-1]){\n                int changingTemp = orderedScoville[(temp+1)/2-1];\n                orderedScoville[(temp+1)/2-1] = orderedScoville[temp];\n                orderedScoville[temp] = changingTemp;\n                temp = (temp+1)/2-1;\n            }else{\n                break;\n            }\n        }\n    }\n\n    int poll(){\n        int returnValue = orderedScoville[0];\n        orderedScoville[0] = orderedScoville[currentIndex];\n        orderedScoville[currentIndex] = 0;\n        currentIndex--;\n        int temp = 0;\n        while(true){\n            int smallChildIndex = 0;\n            int firstChildIndex = (temp+1)*2-1;\n            int secondChildIndex = (temp+1)*2;\n            if(firstChildIndex&#x3C;=currentIndex &#x26;&#x26; secondChildIndex&#x3C;=currentIndex) {\n                smallChildIndex = orderedScoville[firstChildIndex]>orderedScoville[secondChildIndex]?secondChildIndex:firstChildIndex;\n            }else if(firstChildIndex&#x3C;=currentIndex &#x26;&#x26; secondChildIndex>currentIndex) {\n                smallChildIndex = firstChildIndex;\n            }else {\n                break;\n            }\n            if(orderedScoville[temp]>orderedScoville[smallChildIndex]){\n                int changingTemp = orderedScoville[smallChildIndex];\n                orderedScoville[smallChildIndex] = orderedScoville[temp];\n                orderedScoville[temp] = changingTemp;\n                temp = smallChildIndex;\n            }else{\n                break;\n            }\n        }\n        return returnValue;\n    }\n\n    public int solution(int[] scoville, int K) {\n        int answer = 0;\n        orderedScoville = new int[scoville.length];\n        for(int i = 0;i&#x3C;scoville.length;i++)\n            offer(scoville[i]);\n        while(orderedScoville[0]&#x3C;K &#x26;&#x26; currentIndex>0){\n            answer++;\n            offer(poll()+poll()*2);\n        }\n        if(currentIndex==0&#x26;&#x26;orderedScoville[0]&#x3C;K)\n            return -1;\n        return answer;\n    }\n}\n</code></pre>\n<ul>\n<li>\n<p>결과</p>\n<ul>\n<li>정확성: 전체 통과</li>\n<li>효율성: 전체 통과</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>min Heap을 응용하여 구현된 우선순위 큐를 활용한 풀이</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.*;\nclass Solution {\n    public int solution(int[] scoville, int K) {\n        int answer = 0;\n        PriorityQueue&#x3C;Integer> scovillePriorityQueue = new PriorityQueue&#x3C;Integer>();\n        for(int scovilleValue:scoville)\n            scovillePriorityQueue.offer(scovilleValue);\n        while(scovillePriorityQueue.peek()&#x3C;K &#x26;&#x26; scovillePriorityQueue.size()>1){\n            answer++;\n            scovillePriorityQueue.offer(scovillePriorityQueue.poll()+scovillePriorityQueue.poll()*2);\n        }\n        if(scovillePriorityQueue.size()==1 &#x26;&#x26; scovillePriorityQueue.peek()&#x3C;K)\n            return -1;\n        return answer;\n    }\n}\n</code></pre>\n<ul>\n<li>\n<p>결과</p>\n<ul>\n<li>정확성: 전체 통과</li>\n<li>효율성: 전체 통과</li>\n</ul>\n</li>\n</ul>","title":"프로그래머스 더 맵게","date":"2019-12-27 08:26:28 -0400"}}}